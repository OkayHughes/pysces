<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pysces.distributed_memory.multiprocessing module &#8212; pysces  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-pysces.distributed_memory.multiprocessing">
<span id="pysces-distributed-memory-multiprocessing-module"></span><h1>pysces.distributed_memory.multiprocessing module<a class="headerlink" href="#module-pysces.distributed_memory.multiprocessing" title="Link to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.accumulate_fields_for">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">accumulate_fields_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fijk_fields</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert_redundancy_receive</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.accumulate_fields_for" title="Link to this definition">¶</a></dt>
<dd><p>Sum non-processor-local redundant DOFs into a list of processor-local 3D fields after
inter-process communication using a for loop.</p>
<p><em>Designed for testing and debugging only,
do not use in performance code</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fijk_fields</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of fields from which to extract redundant dofs to ship off
to remote processors.</p>
</dd>
<dt><strong>buffers: `dict[remote_proc_idx, [Array[tuple[point_idx, level_idx], Float]]]`</strong></dt><dd><p>a mapping from <cite>remote_proc_idx</cite> to a list
of buffers of redundant DOFs, preserving the number of levels in each field.</p>
</dd>
<dt><strong>vert_redundancy_receive</strong><span class="classifier"><cite>dict[remote_proc_idx, list[tuple[elem_idx, gll_idx, gll_idx]]]</cite></span></dt><dd><p>Mapping from remote_proc_idx to a list of tuples of processor-local indexes into which
redundant DOFs will be summed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fijk_fields</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of fields into which non-processor-local redundant dofs have been summed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of levels in <cite>fijk_fields[field_idx]</cite> may vary across <cite>field_idx</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.accumulate_fields_triple">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">accumulate_fields_triple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fijk_fields</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triples_receive</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.accumulate_fields_triple" title="Link to this definition">¶</a></dt>
<dd><p>Sum non-processor-local redundant DOFs into a list of processor-local 3D fields after
inter-process communication using assembly triples.</p>
<p><em>Can be used in performance code.</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fijk_fields</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of fields from which to extract redundant dofs to ship off
to remote processors.</p>
</dd>
<dt><strong>buffers: `dict[remote_proc_idx, [Array[tuple[point_idx, level_idx], Float]]]`</strong></dt><dd><p>a mapping from <cite>remote_proc_idx</cite> to a list
of buffers of redundant DOFs, preserving the number of levels in each field.</p>
</dd>
<dt><strong>triples_receive: `dict[remote_proc_idx, tuple[Array[tuple[point_idx], Float],                                               Array[tuple[point_idx], Int],                                               Array[tuple[point_idx], Int]]`</strong></dt><dd><p>Mapping from remote_proc_idx to a list of tuples of processor-local indexes into which
redundant DOFs will be summed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>fijk_fields</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of fields into which non-processor-local redundant dofs have been summed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of levels in <cite>fijk_fields[field_idx]</cite> may vary across <cite>field_idx</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.dss_scalar_for_mpi">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">dss_scalar_for_mpi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.dss_scalar_for_mpi" title="Link to this definition">¶</a></dt>
<dd><p>Perform assembly on a list of processor-local scalars using a for loop.</p>
<p><em>Only used for testing, do not use in performance-critical code</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fs</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]</cite></span></dt><dd><p>List of processor-local 2D scalars to perform assembly on.</p>
</dd>
<dt><strong>grids</strong><span class="classifier"><cite>list[dict[str, Any]]</cite></span></dt><dd><p>List of grids, each of which contains
“vert_redundancy_send” and “vert_redundancy_receive”, and “vert_redundancy_local”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]</cite></dt><dd><p>List of continuous processor-local scalars on which assembly was performed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Error</dt><dd><p>Raises any error that can be raised by exchange_buffers_mpi function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>See <cite>se_grid.create_spectral_element_grid</cite> with <cite>proc_idx=local_proc_idx</cite></p></li>
</ul>
<p>for how to create the <cite>grids[proc_idx]</cite> entries.
* To create your own dummy grid, see <cite>se_grid.vert_redundancy_triage</cite>
for how to create “vert_redundancy_send”, “vert_redundancy_receive”,
and “vert_redundancy_local”.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.dss_scalar_for_stub">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">dss_scalar_for_stub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs_global</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.dss_scalar_for_stub" title="Link to this definition">¶</a></dt>
<dd><p>Perform assembly on a list of scalars assuming all data is processor local
using stub communicator and a for loop.</p>
<p><em>Only intended for testing and debugging.</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fs_global</strong><span class="classifier"><cite>list[list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]]</cite></span></dt><dd><p>List of length <cite>num_proc</cite>, where fs_global[proc_idx]
is a list of “processor-local” 2D scalars to perform assembly on.</p>
</dd>
<dt><strong>grids</strong><span class="classifier"><cite>list[dict[str, Any]]</cite></span></dt><dd><p>List of grids containing “vert_redundancy_send”,
“vert_redundancy_receive”, and “vert_redundancy_local”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>list[list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]]</cite></dt><dd><p>List of length <cite>num_proc</cite>, where <cite>fs_global[proc_idx]</cite>
is a list of C0 “processor-local” 2D scalars on which assembly has been performed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>See <cite>se_grid.create_spectral_element_grid</cite> with <cite>proc_idx=local_proc_idx</cite></p></li>
</ul>
<p>for how to create the <cite>grids[local_proc_idx]</cite> entries.
* To calculate <cite>fs_global[proc_idx][field_idx]</cite>,
use <cite>se_grid.subset_var</cite> to subdivide a given <cite>f</cite> calculated
using an entire grid, or re-calculate <cite>f</cite> using, e.g.,
<cite>grids[proc_idx][“physical_coords]</cite>.
* To create your own dummy grid, see <cite>se_grid.vert_redundancy_triage</cite>
for how to create “vert_redundancy_send”, “vert_redundancy_receive”,
and “vert_redundancy_local” entries.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.dss_scalar_triple_mpi">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">dss_scalar_triple_mpi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.dss_scalar_triple_mpi" title="Link to this definition">¶</a></dt>
<dd><p>Perform assembly on a list of processor-local scalars using assembly triples.</p>
<p>Can be used for performance code.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fs</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]</cite></span></dt><dd><p>List of processor-local 2D scalars to perform assembly on.</p>
</dd>
<dt><strong>grids</strong><span class="classifier"><cite>list[dict[str, Any]]</cite></span></dt><dd><p>List of grids, each of which contains
“triples_send”, “triples_receive”, and “dss_triple”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]</cite></dt><dd><p>List of continuous processor-local scalars on which assembly was performed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Error</dt><dd><p>Raises any error that can be raised by <cite>exchange_buffers_mpi</cite> function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>See <cite>se_grid.create_spectral_element_grid</cite> with <cite>proc_idx=local_proc_idx</cite></p></li>
</ul>
<p>for how to create the <cite>grids[proc_idx]</cite> entries.
* To create your own dummy grid, see <cite>se_grid.vert_redundancy_triage</cite>
for how to create “vert_redundancy_send”, “vert_redundancy_receive”,
and “vert_redundancy_local”, then see
<cite>se_grid.init_dss_global</cite> and <cite>se_grid.init_dss_local</cite> for how to generate
(“triples_send”, “triples_receive”), and “dss_triple”, respectively.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.dss_scalar_triple_pack">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">dss_scalar_triple_pack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs_local</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.dss_scalar_triple_pack" title="Link to this definition">¶</a></dt>
<dd><p>Extract processor-local list of scalars before
inter-process communication using assembly triples.</p>
<p>Assembly triples are designed for use in wrapped code, and
have the best shot of being compatible with automatic differentiation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fs_local</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of 2D scalar fields to extract for communication</p>
</dd>
<dt><strong>grid</strong><span class="classifier"><cite>dict[str, Any]</cite></span></dt><dd><p>Processor-local Spectral Element Grid struct.
Contains “triples_send” key, which
has type <cite>dict[remote_proc_idx, tuple[Array[tuple[point_idx], Float],                                           Array[tuple[point_idx], Int],                                           Array[tuple[point_idx], Int]]]</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>dict[proc_idx, list[Array[tuple[local_point_idx, 1], Float]]</cite></dt><dd><p>Mapping from the destination processor idx to an array
of values where <cite>buffer[remote_proc_idx][pt_idx, 1]</cite> is being sent to
<cite>remote_proc_idx</cite> and summed into
<cite>point_idx = triples_receive[local_proc_idx][1][pt_idx]</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See <cite>se_grid.create_spectral_element_grid</cite>
for an example of what this struct looks like.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.dss_scalar_triple_stub">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">dss_scalar_triple_stub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs_global</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.dss_scalar_triple_stub" title="Link to this definition">¶</a></dt>
<dd><p>Perform assembly on a list of scalars assuming all data is processor local
using stub communicator and assembly triples.</p>
<p><em>Only intended for testing and debugging.</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fs_global</strong><span class="classifier"><cite>list[list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]]</cite></span></dt><dd><p>List of length <cite>num_proc</cite>, where fs_global[proc_idx]
is a list of “processor-local” 2D scalars to perform assembly on.</p>
</dd>
<dt><strong>grids</strong><span class="classifier"><cite>list[dict[str, Any]]</cite></span></dt><dd><p>List of grids containing “triples_send”,
“triples_receive”, and “dss_triple”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>list[list[Array[tuple[elem_idx, gll_idx, gll_idx], Float]]]</cite></dt><dd><p>List of length <cite>num_proc</cite>, where <cite>fs_global[proc_idx]</cite>
is a list of C0 “processor-local” 2D scalars on which assembly has been performed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>See <cite>se_grid.create_spectral_element_grid</cite> with <cite>proc_idx=local_proc_idx</cite></p></li>
</ul>
<p>for how to create the <cite>grids[proc_idx]</cite> entries.
* To calculate <cite>fs_global[proc_idx][field_idx]</cite>,
use <cite>se_grid.subset_var</cite> to subdivide a given <cite>f</cite> calculated
using an entire grid, or re-calculate <cite>f</cite> using, e.g.,
<cite>grids[proc_idx][“physical_coords]</cite>.
* To create your own dummy grid, see <cite>se_grid.vert_redundancy_triage</cite>
for how to create “vert_redundancy_send”, “vert_redundancy_receive”,
and “vert_redundancy_local”, then see
<cite>se_grid.init_dss_global</cite> and <cite>se_grid.init_dss_local</cite> for how to generate
(“triples_send”, “triples_receive”), and “dss_triple”, respectively.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.dss_scalar_triple_unpack">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">dss_scalar_triple_unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs_local</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.dss_scalar_triple_unpack" title="Link to this definition">¶</a></dt>
<dd><p>Sum non-processor-local redundancies into list of scalars
after inter-process communication using assembly triples.</p>
<p>Assembly triples are designed for use in wrapped code, and
have the best shot of being compatible with automatic differentiation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fs_local</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of scalar fields to extract for communication</p>
</dd>
<dt><strong>buffers: `dict[proc_idx, list[Array[tuple[local_point_idx, 1], Float]]`</strong></dt><dd><p>Mapping from the (remote) source processor idx to an array
of values where <cite>buffer[remote_proc_idx][pt_idx, 1]</cite> is being sent to
<cite>proc_idx</cite> and summed on <cite>proc_idx</cite> into
<cite>point_idx = triples_receive[proc_idx][1][pt_idx]</cite></p>
</dd>
<dt><strong>grid</strong><span class="classifier"><cite>dict[str, Any]</cite></span></dt><dd><p>Processor-local Spectral Element Grid struct.
Contains “triples_receive” key, which
has type <cite>dict[remote_proc_idx, tuple[Array[tuple[point_idx], Float],                                           Array[tuple[point_idx], Int],                                           Array[tuple[point_idx], Int]]]</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></dt><dd><p>List of scalar fields into which redundant DOFS have been summed.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See <cite>se_grid.create_spectral_element_grid</cite>
for an example of what this struct looks like.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.exchange_buffers_mpi">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">exchange_buffers_mpi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.exchange_buffers_mpi" title="Link to this definition">¶</a></dt>
<dd><p>Exchange Spectral Element grid non-processor-local redundant DOFS
between processes using the Message Passing Interface.</p>
<p><strong>This function is the only function in the entire codebase
that will hang indefinitely in the event of, e.g., hardware failures
on a remote processor, or other distributed-memory shenanigans.</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>buffer: `dict[proc_idx, list[Array[tuple[point_idx, level_idx], Float]]]`</strong></dt><dd><p>A buffer struct that maps <cite>proc_idx</cite> to a
list of arrays containing redundant DOFs to send to that processor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>buffer: <cite>dict[proc_idx, list[Array[tuple[point_idx, level_idx], Float]]]</cite></dt><dd><p>A buffer struct that maps <cite>proc_idx</cite> to a
list of arrays containing redundant DOFs received from that processor.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Error</dt><dd><p>Any error that can be raised by the following two functions:
* <cite>mpi_comm.Isendrecv_replace</cite>
* <cite>MPI.Request.Waitall</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>mpi4py is designed to accept objects that buffer properties
that resemble np.ndarrays. This function can almost certainly
be designed in a way that can leverage gpu-aware MPI environments,
but this functionality has not yet been tested.
Divergence in how this is performed with different wrapper types
is acceptable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.exchange_buffers_stub">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">exchange_buffers_stub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.exchange_buffers_stub" title="Link to this definition">¶</a></dt>
<dd><p>Exchange buffers between source dofs and target dofs assuming that all grid is processor-local.</p>
<p><em>Only used for testing and debugging, do not use in performance
code</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>buffer_list: `list[dict[proc_idx, list[Array[tuple[point_idx, level_idx], Float]]]]`</strong></dt><dd><p>A list of length num_processors, each of which is a buffer struct
that maps <cite>proc_idx</cite> to a list of arrays containing redundant DOFs to send.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>list[dict[proc_idx, list[Array[tuple[point_idx, level_idx], Float]]]]</cite></dt><dd><p>A list of length num_processors, each of which is a buffer struct
that maps proc_idx to a list of arrays containing redundant DOFs that were received.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function exchanges the memory reffered to by <cite>buffer_list[proc_idx][remote_proc_idx][field_idx]</cite>
with <cite>buffer_list[remote_proc_idx][proc_idx][field_idx]</cite>.
The behavior should be almost identical to how exchange_buffers_mpi
behaves when called when has_mpi=True, except for this difference.</p>
<p>By construction, if any grid point <cite>(elem_idx_source, i_idx_source, j_idx_source) `
that has a redundancy with `(elem_idx_target, i_idx_target, j_idx_target)</cite>,
this relation is symmetric. Therefore, the number of grid points
necessary to send from <cite>proc_idx_1</cite> to <cite>proc_idx_2</cite> is identical
to the number to send from <cite>proc_idx_2</cite> to <cite>proc_idx_1</cite>.
The indexes of points in the buffer that is sent
will be different from those in the buffer that is received,
but so long as both processes agree on the different orderings,
this is fine.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.extract_fields_for">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">extract_fields_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fijk_fields</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vert_redundancy_send</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.extract_fields_for" title="Link to this definition">¶</a></dt>
<dd><p>Extract values from a list of processor-local 3D fields before
inter-process communication using a for loop.</p>
<p><em>Designed for testing and debugging only,
do not use in performance code</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fijk_fields</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of fields from which to extract redundant dofs to ship off
to remote processors.</p>
</dd>
<dt><strong>vert_redundancy_send</strong><span class="classifier"><cite>dict[remote_proc_idx, list[tuple[elem_idx, gll_idx, gll_idx]]]</cite></span></dt><dd><p>Mapping from <cite>remote_proc_idx</cite> to a list of tuples of processor_local info
to ship off to <cite>remote_proc_idx</cite>.
Values are extracted as <cite>fijk_fields[field_idx][elem_idx, i_idx, j_idx, :]</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>dict[remote_proc_idx, [Array[tuple[point_idx, level_idx], Float]]]</cite></dt><dd><p>a mapping from <cite>remote_proc_idx</cite> to a list
of buffers of redundant DOFs, preserving the number of levels in each field.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of levels in <cite>fijk_fields[field_idx]</cite> may vary across <cite>field_idx</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.extract_fields_triple">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">extract_fields_triple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fijk_fields</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triples_send</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.extract_fields_triple" title="Link to this definition">¶</a></dt>
<dd><p>Extract values from a list of processor-local 3D fields before
inter-process communication using assembly triples.</p>
<p><em>This can be used in performance code.</em></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fijk_fields</strong><span class="classifier"><cite>list[Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]]</cite></span></dt><dd><p>List of fields from which to extract redundant dofs to ship off
to remote processors.</p>
</dd>
<dt><strong>triples_send</strong><span class="classifier"><cite>dict[remote_proc_idx, tuple[Array[tuple[point_idx], Float],                                            Array[tuple[point_idx], Int],                                            Array[tuple[point_idx], Int]]</cite></span></dt><dd><p>Mapping from <cite>remote_proc_idx</cite> to an assembly triple describing info
to ship off to <cite>remote_proc_idx</cite>.</p>
<p>Values are extracted as <cite>fijk_fields[field_idx][elem_idx, i_idx, j_idx, :]</cite></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><cite>dict[remote_proc_idx, list[Array[tuple[point_idx, level_idx], Float]]]</cite></dt><dd><p>A mapping from <cite>remote_proc_idx</cite> to a list
of buffers of redundant DOFs, preserving the number of levels in each field.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number of levels in <cite>fijk_fields[field_idx]</cite> may vary across <cite>field_idx</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pysces.distributed_memory.multiprocessing.sum_into">
<span class="sig-prename descclassname"><span class="pre">pysces.distributed_memory.multiprocessing.</span></span><span class="sig-name descname"><span class="pre">sum_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fijk_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysces.distributed_memory.multiprocessing.sum_into" title="Link to this definition">¶</a></dt>
<dd><p>Sum redundant dofs into a 3D field using assembly triples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fijk_field: `Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]`</strong></dt><dd><p>Field values into which the values in buffer will be summed</p>
</dd>
<dt><strong>buffer: `Array[tuple[point_idx, level_idx], Float]`</strong></dt><dd><p>Redundant DOFs</p>
</dd>
<dt><strong>rows: `Array[tuple[point_idx], Int]`</strong></dt><dd><p>Indexes of redundant dofs, namely
<cite>fijk_field[:, :, :, k_idx].flatten()[row[point_idx]]</cite> corresponds to
buffer[point_idx, k_idx].</p>
</dd>
<dt><strong>dims: `frozendict[str, Any]`</strong></dt><dd><p>Hashable dictionary containing key “shape”, which is the shape of <cite>fijk_field</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>fijk_field: <cite>Array[tuple[elem_idx, gll_idx, gll_idx, level_idx], Float]</cite></dt><dd><p>Field values into which the values in buffer have been summed</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The implementation of this function is allowed to depend on wrapper_type.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pysces</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2026, Owen K Hughes.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/api/pysces.distributed_memory.multiprocessing.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>